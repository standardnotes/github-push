'use strict';

/* eslint-env mocha */
var _require = require('chai'),
    expect = _require.expect;

var _require2 = require('../test-config'

// NodeJS does not have a btoa
),
    client = _require2.client,
    LONG_TIMEOUT = _require2.LONG_TIMEOUT,
    test_repo = _require2.test_repo;

var btoa = null;

if (typeof window !== 'undefined' && window !== null) {
  btoa = window.btoa;
  // Use the `Buffer` if available (NodeJS)
} else if (typeof global !== 'undefined' && global !== null) {
  btoa = function btoa(str) {
    var buffer = new global['Buffer'](str, 'binary');
    return buffer.toString('base64');
  };
} else {
  throw new Error('Native btoa function or Buffer is missing');
}

describe('Contents', function () {
  this.timeout(LONG_TIMEOUT);

  it('returns the default readme', function () {
    return client.repos('octokit/octokit.rb').readme.read().then(function (readme) {});
  }
  // expect(readme.encoding).to.equal("base64")
  // expect(readme.type).to.equal("file")

  );it('returns the contents of a file', function () {
    return client.repos('octokit/octokit.rb').contents('lib/octokit.rb').read().then(function (contents) {});
  }
  // expect(contents.encoding).to.equal("base64")
  // expect(contents.type).to.equal("file")

  // it "returns the headers of the request", ->
  //   client.repos('octokit/octokit.rb').tarball('master').fetch()
  //   .then(null, (err) -> console.log err)
  //   .then (archive_link) ->
  //     expect(archive_link).to.equal('https://codeload.github.com/octokit/octokit.rb/legacy.tar.gz/master')

  );context('With a file', function () {
    beforeEach(function (done) {
      var removeFile = function removeFile(content) {
        var config = {
          sha: content.sha,
          message: 'Removing as prep for testing'
        };
        return client.repos(test_repo).contents('test_create.txt').remove(config).then(function () {
          return done();
        });
      };

      // If the file exists, remove it. Otherwise, done.
      client.repos(test_repo).contents('test_create.txt').fetch
      /* eslint handle-callback-err: "off" */
      ().then(removeFile, function (err) {
        return done();
      }

      // In Mocha 3, if the returned value is a promise then it will complain that
      // we have specified a done() callback _and_ returned a promise.
      // So, since this test should always succeed even if there is no file (to delete)
      // just return null so Mocha does not complain.
      );return null;
    });

    it('creates repository contents at a path', function () {
      var repo = client.repos(test_repo);
      return repo.fetch().then(function (_ref) {
        var defaultBranch = _ref.defaultBranch;

        return repo.branches(defaultBranch).fetch().then(function (_ref2) {
          var commit = _ref2.commit;

          var config = {
            message: 'I am commit-ing',
            content: btoa('Here be the content\n')
          };
          return repo.contents('test_create.txt').add(config).then(null, function (err) {
            console.log(err);throw new Error(err);
          }).then(function (response) {
            return expect(response.commit.sha).to.match(/[a-z0-9]{40}/);
          });
        });
      });
    });

    it('updates repository contents at a path', function () {
      // Prep work (from previous test)
      var repo = client.repos(test_repo);
      return repo.fetch().then(function (_ref3) {
        var defaultBranch = _ref3.defaultBranch;

        return repo.branches(defaultBranch).fetch().then(function (_ref4) {
          var commit = _ref4.commit;

          var config = {
            message: 'I am commit-ing',
            content: btoa('Here be the content\n')
          };
          return repo.contents('test_create.txt').add(config).then(null, function (err) {
            console.log(err);throw new Error(err);
          }).then(function (response) {

            // Test Start
            var config = {
              sha: response.content.sha,
              message: 'I am commit-ing',
              content: btoa('Here be moar content')
            };
            return client.repos(test_repo).contents('test_create.txt').add(config).then(function (response2) {
              return expect(response2.commit.sha).to.match(/[a-z0-9]{40}/);
            });
          });
        });
      });
    });

    it('deletes repository contents at a path', function () {
      // Prep work (from previous test)
      var repo = client.repos(test_repo);
      return repo.fetch().then(function (_ref5) {
        var defaultBranch = _ref5.defaultBranch;

        return repo.branches(defaultBranch).fetch().then(function (_ref6) {
          var commit = _ref6.commit;

          var config = {
            message: 'I am commit-ing',
            content: btoa('Here be the content\n')
          };
          return repo.contents('test_create.txt').add(config).then(null, function (err) {
            console.log(err);throw new Error(err);
          }).then(function (response) {
            expect(response.commit.sha).to.match(/[a-z0-9]{40}/

            // Test Start
            );var config = {
              sha: response.content.sha,
              message: 'I am rm-ing'
            };
            return client.repos(test_repo).contents('test_create.txt').remove(config).then(function (response) {
              expect(response.url).is.a('string');
            });
          });
        });
      });
    });
  });
}

// TODO: have a non-boolean form of remove()
// expect(response.commit.sha).to match(/[a-z0-9]{40}/)
);
//# sourceMappingURL=contents.spec.js.map